#!/usr/bin/env bash

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Return an image:tag for the specified builder docker image
#     Given the input files (Dockerfile, configs, installation scripts etc) for building the docker
#     image, first generate a hash of the file contents (ie. exclude timestamps, file ownership etc).
#     This hash will be used as the image tag

set -o pipefail
set -o errexit

VERBOSE=0
BUILD_IMAGE_IF_NEEDED=1

trap _cleanup EXIT
function _cleanup() {
  declare -r -i STATUS=$?
  if [[ -n ${TEMPTAR} ]]; then
    rm -f "${TEMPTAR}"
  fi
  if [[ ${STATUS} -ne 0 ]]; then
    printf "Error: get-builder-image-tagged status code: %d\n" "${STATUS}" &>/dev/stderr
  fi
  exit ${STATUS}
}

declare -r -A IMAGE_NAMES=(
  [build-debian]="privacysandbox/builders/build-debian"
  [build-amazonlinux2]="privacysandbox/builders/build-amazonlinux2"
  [presubmit]="privacysandbox/builders/presubmit"
  [release]="privacysandbox/builders/release"
  [utils]="privacysandbox/builders/utils"
)

function usage() {
  declare -r -i exitval=${1-1}
  cat &>/dev/stderr <<USAGE
usage:
  $0 <options>
    --no-build           Do not build image if it doesn't exist
    --image              Image name for the build runtime. Valid names:
USAGE

  for elem in "${!IMAGE_NAMES[@]}"
  do
    if [[ ${IMAGE} == "${elem}" ]]; then
      local EXTRA=" (default)"
    fi
    printf "                             *  %s%s\n" "${elem}" "${EXTRA}" &>/dev/stderr
  done

  cat &>/dev/stderr <<USAGE
    --verbose            Enable verbose output
USAGE
  # shellcheck disable=SC2086
  exit ${exitval}
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --image)
      IMG="$2"
      shift
      shift
      ;;
    --no-build)
      BUILD_IMAGE_IF_NEEDED=0
      shift
      ;;
    --verbose)
      VERBOSE=1
      shift
      ;;
    -h | --help) usage 0 ;;
    *)
      printf "unrecognized arg: %s\n" "$1"
      usage
      ;;
  esac
done

TOOLS_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
readonly TOOLS_DIR
readonly ETC_DIR="${TOOLS_DIR}"/../etc
readonly IMAGES_DIR="${TOOLS_DIR}"/../images
# shellcheck disable=SC1091
source "${TOOLS_DIR}"/builder.sh
WORKSPACE_MOUNT="$(builder::get_docker_workspace_mount)"
readonly WORKSPACE_MOUNT

if [[ -z ${IMG} ]]; then
  printf -- "error: --image must be specified\n" &>/dev/stderr
  usage 1
fi

readonly IMAGE_NAME=${IMAGE_NAMES[${IMG}]}
if [[ -z ${IMAGE_NAME} ]]; then
  printf -- "error: image [%s] not recognized\n" "${IMG}" &>/dev/stderr
  usage 1
fi

IMAGE_PATH_FULL="${IMAGES_DIR}/${IMG}"
if ! [[ -s ${IMAGE_PATH_FULL}/Dockerfile ]]; then
  printf "error: unable to locate [%s/Dockerfile]\n" "${IMAGE_PATH_FULL}" &>/dev/stderr
  exit 1
fi
TEMPTAR="$(mktemp --dry-run --suffix=.tar.gz)"
readonly TEMPTAR

# install gnu tar into a docker image
function tar_image() {
  declare -r TAR_IMAGE=builders/tar-get-builder-image-tagged
  {
  cat <<Dockerfile
FROM alpine:3.16
RUN apk --no-cache add tar=1.34-r0
Dockerfile
} | docker buildx build --quiet --tag ${TAR_IMAGE} - &>/dev/null
  printf "%s" "${TAR_IMAGE}"
}

# use tar to copy files between directories, dereferencing symbolic links,
# skipping the test subdirectory
function tar_cp() {
  local -r SRC="$(realpath "$1")"
  local -r FILES="$2"
  local -r DEST="$3"

  local -r TAR_IMAGE="$(tar_image)"
  docker run --rm \
    --entrypoint=/bin/sh \
    --volume "${WORKSPACE_MOUNT}:${WORKSPACE_MOUNT}" \
    --volume "${DEST}:${DEST}" \
    "${TAR_IMAGE}" -c "
tar --create --dereference --directory='${SRC}' --exclude=test ${FILES} \
  | tar --extract --directory='${DEST}'
"
}

# Try to create a deterministic tar file for the specified file path
# Any etc files in the $WORKSPACE (root) directory override the etc
# files in the image dir, as long as it's a file also found in the
# builders etc directory
function _create_tar() {
  local -r TARFILE="$1"
  local -r FILEPATH="$2"
  local -r TMP_IMAGE_DIR="$(mktemp --directory)"

  tar_cp "${FILEPATH}" "." "${TMP_IMAGE_DIR}"

  # find workspace etc files that are also in the image dir and the builders etc dir
  # shellcheck disable=SC2012
  local -r WORKSPACE_ETC_FILES="$({
    ls -A -1 "${FILEPATH}" "${ETC_DIR}" | sort | uniq -d
    ls -A -1 "${WORKSPACE}"
  } | sort | uniq -d)"
  # overwrite etc files in the image with the WORKSPACE's etc files
  if [[ -n ${WORKSPACE_ETC_FILES} ]]; then
    tar_cp "${WORKSPACE}" "${WORKSPACE_ETC_FILES}" "${TMP_IMAGE_DIR}"
  fi

  local -r TAR_IMAGE="$(tar_image)"
  # create a deterministic tarball of the collected files
  touch "${TARFILE}"
  docker run --rm \
    --entrypoint=/bin/sh \
    --volume "${TMP_IMAGE_DIR}:${TMP_IMAGE_DIR}" \
    --volume "${TARFILE}:${TARFILE}" \
    "${TAR_IMAGE}" -c "
tar --create --dereference --sort=name --owner=0 --group=0 --numeric-owner --format=gnu --directory='${TMP_IMAGE_DIR}' --file='${TARFILE}' .
" &> /dev/null
  rm -rf "${TMP_IMAGE_DIR}"
}

_create_tar "${TEMPTAR}" "${IMAGE_PATH_FULL}"
# use the tarfile size and file content to generate a sha256 hash
SHA=$({ echo -ne "blob $(wc -c < "${TEMPTAR}")\0"; tar --extract --file="${TEMPTAR}" --to-stdout; } | sha256sum | cut -f1 -d" ")
ARCH="$("${TOOLS_DIR}"/get-architecture)"
readonly ARCH
readonly IMAGE_TAG="${ARCH}-${SHA}"
if [[ ${VERBOSE} -eq 1 ]]; then
  printf "tag for docker inputs: %s\n" "${IMAGE_TAG}" &>/dev/stderr
fi
readonly IMAGE_TAGGED="${IMAGE_NAME}:${IMAGE_TAG}"
printf "%s\n" "${IMAGE_TAGGED}"

if [[ ${BUILD_IMAGE_IF_NEEDED} -eq 1 ]]; then
  # Create a builder docker image
  # build container image and load it into the local docker client
  if ! docker image inspect "${IMAGE_TAGGED}" &>/dev/null; then
    printf "generating docker image %s\n" "${IMAGE_TAGGED}" &>/dev/stderr
    docker buildx build --tag "${IMAGE_TAGGED}" - <"${TEMPTAR}" &>/dev/stderr
  fi
fi
